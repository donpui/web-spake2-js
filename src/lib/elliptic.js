import BN from 'bn.js'
import elliptic from 'elliptic'
import { toBytes, fromHex } from './bytes.js'

const { ec: EC } = elliptic

function bnFromLittleEndian (bytes) {
  let hex = ''
  for (let i = bytes.length - 1; i >= 0; i--) {
    hex += bytes[i].toString(16).padStart(2, '0')
  }
  return hex.length > 0 ? new BN(hex, 16) : new BN(0)
}

const TWO_POW_255 = new BN(2).pow(new BN(255))

/**
 * @typedef {object} Curve
 * @property {string} name The curve identifier understood by elliptic.
 * @property {string} M SEC1-encoded coordinate of M.
 * @property {string} N SEC1-encoded coordinate of N.
 * @property {BN} [p] Order of the subgroup generated by P.
 * @property {BN} [h] Cofactor of the subgroup generated by P.
 * @property {string} [pointFormat] Preferred point encoding ('uncompressed' or 'compressed').
 */

const curveEd25519 = {
  name: 'ed25519',
  M: 'd048032c6ea0b6d697ddc2e86bda85a33adac920f1bf18e1b0c6d166a5cecdaf',
  N: 'd3bfb518f44f3430f29d0c92af503865a1ed3281dc69b35dd868ba85f886c4ab',
  p: new BN('7237005577332262213973186563042994240857116359379907606001950938285454250989', 10),
  h: new BN(8),
  pointFormat: 'edwards'
}

const curveP256 = {
  name: 'p256',
  M: '02886e2f97ace46e55ba9dd7242579f2993b64e16ef3dcab95afd497333d8fa12f',
  N: '03d8bbd6c639c62937b04d997f38c3770719c629d7014d49a24b4f98baa1292b49',
  h: new BN(1),
  pointFormat: 'uncompressed'
}

const curveP384 = {
  name: 'p384',
  M: '030ff0895ae5ebf6187080a82d82b42e2765e3b2f8749c7e05eba366434b363d3dc36f15314739074d2eb8613fceec2853',
  N: '02c72cf2e390853a1c1c4ad816a62fd15824f56078918f43f922ca21518f9c543bb252c5490214cf9aa3f0baab4b665c10',
  h: new BN(1),
  pointFormat: 'uncompressed'
}

const curveP521 = {
  name: 'p521',
  M: '02003f06f38131b2ba2600791e82488e8d20ab889af753a41806c5db18d37d85608cfae06b82e4a72cd744c719193562a653ea1f119eef9356907edc9b56979962d7aa',
  N: '0200c7924b9ec017f3094562894336a53c50167ba8c5963876880542bc669e494b2532d76c5b53dfb349fdf69154b9e0048c58a42e8ed04cef052a3bc349d95575cd25',
  h: new BN(1),
  pointFormat: 'uncompressed'
}

/**
 * Enumerate the curves.
 *
 * @readonly
 * @enum {Curve}
 */
const CURVES = {
  ed25519: curveEd25519,
  p256: curveP256,
  p384: curveP384,
  p521: curveP521
}

class Elliptic {
  constructor (curveDefinition) {
    const ec = new EC(curveDefinition.name)
    this.name = curveDefinition.name
    this.ecInstance = ec
    this.ec = ec.curve
    this.curve = this.ec
    this.pointFormat = curveDefinition.pointFormat || 'compressed'

    const providedOrder = curveDefinition.p
    this.p = providedOrder || new BN(ec.curve.n.toString(16), 16)
    this.scalarBitLength = this.p.bitLength()
    this.scalarLength = Math.ceil(this.scalarBitLength / 8)

    const providedH = curveDefinition.h
    this.h = providedH || new BN(1)

    this.P = this.ecInstance.g
    this.M = this.decodePoint(curveDefinition.M)
    this.N = this.decodePoint(curveDefinition.N)
  }

  decodePoint (value) {
    if (this.name === 'ed25519') {
      const bytes = typeof value === 'string' ? fromHex(value) : toBytes(value)
      const b = bnFromLittleEndian(bytes)
      // b = [x % 2 (1bit)][y (255bits)]
      return this.curve.pointFromY(b.mod(TWO_POW_255).toString(16), b.gte(TWO_POW_255))
    }

    const bytes = typeof value === 'string' ? fromHex(value) : toBytes(value)
    return this.curve.decodePoint(bytes)
  }

  encodePoint (point) {
    if (this.name === 'ed25519') {
      const x = point.getX()
      const y = point.getY()
      return x.mod(new BN(2)).mul(TWO_POW_255).add(y).toArrayLike(Uint8Array, 'le', 32)
    }

    const compressed = this.pointFormat !== 'uncompressed'
    return Uint8Array.from(point.encode('array', compressed))
  }
}

export { CURVES, Elliptic }
